دیتابیس شبکه اجتماعی

توی این تسک قراره که به یه پروژه توی گیتهاب کانتربیوت کنید و به این بهونه مفاهیم branch ،remote ،conflict و pull request رو تمرین کنین.

اینجا ما یه تیکه از کد یک شبکه اجتماعی رو داریم که در اون کاربر ها میتونن همدیگه رو فالو کنن.
هربار که یک کاربر لاگین میکنه یا کاربر دیگه‌ای نام کاربری رو جستجو میکنه برنامه ما توی دیتابیس اکانت‌ها شروع به جستجو میکنه.
اگه دیتابیس برنامه از قبل مرتب شده باشه، فرایند سرچ سریع‌تر پیش میره و چه بسا میشه از الگوریتم‌های سرچ بهینه‌تری هم استفاده کرد.
در ابتدا برنامه نویس‌های این شبکه اجتماعی برای سورت کردن اکانتها از الگوریتم بابل سورت استفاده کردند که سریع و بهینه است.

الگوریتم بابل سورت چیه؟
فرض کنیم که قراره لیست به صورت نزولی مرتب بشه، یعنی از کم به زیاد. طبق این الگوریتم توی یک حلقه هربار لیست رو پیمایش میکنیم و به هر عنصری که می‌رسیم، اون رو با بعدیش مقایسه می‌کنیم و اگه کوچک‌تر از عنصر بعدش بود اون رو با عنصر بعدی جابه‌جا میکنیم و میریم سراغ عنصر بعد. هر بار که کامل لیست رو پیمایش کردیم چک میکنیم که طی این پیمایش آیا عنصری رو با بعدیش جابه‌جا کردیم یا خیر. اگر نکرده باشیم یعنی لیست مرتب بوده و نیازی به جابجایی عناصر نداشتیم.
[توضیح بیشتر این الگوریتم] 

حالا با گذشت زمان این شبکه مخاطب های بیشتری به خودش جذب کرده و دیگه الگوریتم بابل سورت بهینه ترین راه برای سورت کردن داده‌ها نیست.
ما از شما می‌خوایم که برای تابع سورت کلاس AccountList از الگوریتم مرج سورت به جای بابل سورت استفاده کنید.

الگوریتم Merge Sort چیه؟
طبق این الگوریتم ما هربار لیست رو از وسط نصف میکنیم و هر نصف رو جداگونه مرتب می‌کنیم و این نصف کردن رو تا جایی ادامه میدیم که تیکه های جدا شده دو تایی باشن. بعد از اینکه هر قسمت رو مرتب کردیم اون دو تا تیکه مرتب شده رو با هم ادغام می‌کنیم به طوری که همچنان سورت شده باقی بمونن.
این ویدیوی کوتاه به خوبی روش مرج سورت رو بهتون نشون میده.


اما توی این سوال شما نیازی ندارید که خودتون این الگوریتم رو پیاده سازی کنید. پیاده‌سازی اون برای شما این پایین انجام شده و کافیه کپی‌ش کنید:
   
    Account *merge(Account *first, Account *second) 
    {

      if (first == nullptr) return second;
    if (second == nullptr) return first;
    {
        first->next = merge(first->next, second);
        return first;
    }
    else {
        second->next = merge(first, second->next);
        return second;
    }
    }

    Account *MergeSort(Account *head) 
    {
    if (head == nullptr || head->next == nullptr)
        return head;

    // Split the list into two halves
    Node *second = split(head);

    // Recursively sort each half
    head = MergeSort(head);
    second = MergeSort(second);

    // Merge the two sorted halves
    return merge(head, second);
    }


مراحل انجام کار:
۱.این ریپازیتوری رو فورک کنید.
۲.ریپازیتوری فورک شده رو کلون کنید.
۳.شاخه مربوط به این کار رو بسازید برای مثال شاخه change-sort-method یا هر اسم دیگه ای که به نظرتون مناسب این کاره.
۴.تغییرات لازم رو اعمال کنید.
۵.کدتون رو پوش کنید روی شاخه مربوطه.
۶.وارد گیتهاب بشید و یه پول ریکوئست به همین ریپازیتوری و برنچ development بسازید.

۷.Reviewer رو صاحب ریپازیتوری قرار بدید.

